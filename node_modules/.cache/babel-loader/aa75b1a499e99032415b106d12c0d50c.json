{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({\n    schemaCode\n  }) => codegen_1._`{allowedValues: ${schemaCode}}`\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    const eql = util_1.useFunc(gen, equal_1.default);\n    let valid;\n\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = codegen_1.or(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n\n    cxt.pass(valid);\n\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if(codegen_1._`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n    }\n\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? codegen_1._`${eql}(${data}, ${vSchema}[${i}])` : codegen_1._`${data} === ${sch}`;\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/enum.ts"],"names":[],"mappings":";;;;;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAIA,MAAM,KAAK,GAA2B;AACpC,EAAA,OAAO,EAAE,4CAD2B;AAEpC,EAAA,MAAM,EAAE,CAAC;AAAC,IAAA;AAAD,GAAD,KAAkB,SAAA,CAAA,CAAC,mBAAmB,UAAU;AAFpB,CAAtC;AAKA,MAAM,GAAG,GAA0B;AACjC,EAAA,OAAO,EAAE,MADwB;AAEjC,EAAA,UAAU,EAAE,OAFqB;AAGjC,EAAA,KAAK,EAAE,IAH0B;AAIjC,EAAA,KAJiC;;AAKjC,EAAA,IAAI,CAAC,GAAD,EAAgB;AAClB,UAAM;AAAC,MAAA,GAAD;AAAM,MAAA,IAAN;AAAY,MAAA,KAAZ;AAAmB,MAAA,MAAnB;AAA2B,MAAA,UAA3B;AAAuC,MAAA;AAAvC,QAA6C,GAAnD;AACA,QAAI,CAAC,KAAD,IAAU,MAAM,CAAC,MAAP,KAAkB,CAAhC,EAAmC,MAAM,IAAI,KAAJ,CAAU,gCAAV,CAAN;AACnC,UAAM,OAAO,GAAG,MAAM,CAAC,MAAP,IAAiB,EAAE,CAAC,IAAH,CAAQ,QAAzC;AACA,UAAM,GAAG,GAAG,MAAA,CAAA,OAAA,CAAQ,GAAR,EAAa,OAAA,CAAA,OAAb,CAAZ;AACA,QAAI,KAAJ;;AACA,QAAI,OAAO,IAAI,KAAf,EAAsB;AACpB,MAAA,KAAK,GAAG,GAAG,CAAC,GAAJ,CAAQ,OAAR,CAAR;AACA,MAAA,GAAG,CAAC,UAAJ,CAAe,KAAf,EAAsB,QAAtB;AACD,KAHD,MAGO;AACL;AACA,UAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B,MAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AAC5B,YAAM,OAAO,GAAG,GAAG,CAAC,KAAJ,CAAU,SAAV,EAAqB,UAArB,CAAhB;AACA,MAAA,KAAK,GAAG,SAAA,CAAA,EAAA,CAAG,GAAG,MAAM,CAAC,GAAP,CAAW,CAAC,EAAD,EAAc,CAAd,KAA4B,SAAS,CAAC,OAAD,EAAU,CAAV,CAAhD,CAAN,CAAR;AACD;;AACD,IAAA,GAAG,CAAC,IAAJ,CAAS,KAAT;;AAEA,aAAS,QAAT,GAAiB;AACf,MAAA,GAAG,CAAC,MAAJ,CAAW,KAAX,EAAkB,KAAlB;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,UAAf,EAAoC,CAAD,IACjC,GAAG,CAAC,EAAJ,CAAO,SAAA,CAAA,CAAC,GAAG,GAAG,IAAI,IAAI,KAAK,CAAC,GAA5B,EAAiC,MAAM,GAAG,CAAC,MAAJ,CAAW,KAAX,EAAkB,IAAlB,EAAwB,KAAxB,EAAvC,CADF;AAGD;;AAED,aAAS,SAAT,CAAmB,OAAnB,EAAkC,CAAlC,EAA2C;AACzC,YAAM,GAAG,GAAG,MAAM,CAAC,CAAD,CAAlB;AACA,aAAO,OAAO,GAAP,KAAe,QAAf,IAA2B,GAAG,KAAK,IAAnC,GACH,SAAA,CAAA,CAAC,GAAG,GAAG,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,IAD7B,GAEH,SAAA,CAAA,CAAC,GAAG,IAAI,QAAQ,GAAG,EAFvB;AAGD;AACF;;AAnCgC,CAAnC;AAsCA,OAAA,CAAA,OAAA,GAAe,GAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => codegen_1._ `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        const eql = util_1.useFunc(gen, equal_1.default);\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = codegen_1.or(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if(codegen_1._ `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? codegen_1._ `${eql}(${data}, ${vSchema}[${i}])`\n                : codegen_1._ `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}