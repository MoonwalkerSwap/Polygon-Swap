{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst code_1 = require(\"../../vocabularies/code\");\n\nconst errors_1 = require(\"../errors\");\n\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\n\nexports.macroKeywordCode = macroKeywordCode;\n\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid(codegen_1._`await `), e => gen.assign(valid, false).if(codegen_1._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n\n  function validateSync() {\n    const validateErrs = codegen_1._`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n\n  function assignValid(_await = def.async ? codegen_1._`await ` : codegen_1.nil) {\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, codegen_1._`${_await}${code_1.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n\n  function reportErrs(errors) {\n    var _a;\n\n    gen.if(codegen_1.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\n\nexports.funcKeywordCode = funcKeywordCode;\n\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, codegen_1._`${it.parentData}[${it.parentDataProperty}]`));\n}\n\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if(codegen_1._`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);\n    errors_1.extendErrors(cxt);\n  }, () => cxt.error());\n}\n\nfunction checkAsyncKeyword({\n  schemaEnv\n}, def) {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\n\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: codegen_1.stringify(result)\n  });\n}\n\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\n\nexports.validSchemaType = validSchemaType;\n\nfunction validateKeywordUsage({\n  schema,\n  opts,\n  self,\n  errSchemaPath\n}, def, keyword) {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n\n  const deps = def.dependencies;\n\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\n\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"sources":["../../../lib/compile/validate/keyword.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid(codegen_1._ `await `), (e) => gen.assign(valid, false).if(codegen_1._ `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._ `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = codegen_1._ `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? codegen_1._ `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, codegen_1._ `${_await}${code_1.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if(codegen_1.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, codegen_1._ `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if(codegen_1._ `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, codegen_1._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, codegen_1._ `${names_1.default.vErrors}.length`);\n        errors_1.extendErrors(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: codegen_1.stringify(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map"]},"metadata":{},"sourceType":"script"}